# 글자 지우기

## 문제 설명

문자열 my_string과 정수 배열 indices가 주어질 때, my_string에서 indices의 원소에 해당하는 인덱스의 글자를 지우고 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.

**제한사항:**

- 1 ≤ indices의 길이 < my_string의 길이 ≤ 100
- my_string은 영소문자로만 이루어져 있습니다
- 0 ≤ indices의 원소 < my_string의 길이
- indices의 원소는 모두 서로 다릅니다.

**입출력 예:**

```
my_string: "apporoograpemmemprs"
indices: [1, 16, 6, 15, 0, 10, 11, 3]
result: "programmers"
```

## 해결 방법

### 기본 해결법 (splice 사용)

```javascript
function solution(my_string, indices) {
  const arr = [...my_string];
  indices.sort((a, b) => b - a); // 내림차순 정렬
  for (let idx of indices) {
    arr.splice(idx, 1);
  }
  return arr.join("");
}
```

### 개선된 해결법 (Set 사용)

```javascript
function solution(my_string, indices) {
  const removeSet = new Set(indices);
  return my_string
    .split("")
    .filter((char, index) => !removeSet.has(index))
    .join("");
}
```

## 고민한 점

1. **배열 조작 vs 필터링**:

   - 기본 해결법은 splice를 사용해 배열에서 요소를 직접 제거하는 방식입니다.
   - 개선된 해결법은 filter를 사용해 제거할 인덱스가 아닌 요소만 선별하는 방식입니다.

2. **정렬의 필요성**:

   - splice 방식에서는 뒤에서부터 제거해야 인덱스가 변하지 않으므로 내림차순 정렬이 필요합니다.
   - filter 방식에서는 원본 배열을 변경하지 않으므로 정렬이 불필요합니다.

3. **성능 고려사항**:

   - splice 방식: O(n²) - 각 splice 연산이 O(n)이고 최대 n번 실행
   - filter 방식: O(n) - Set 조회는 O(1)이고 filter는 O(n)
   - 개선된 방법이 더 효율적입니다.

4. **가독성과 함수형 프로그래밍**:
   - filter 방식이 더 선언적이고 가독성이 좋습니다.
   - 부수 효과(side effect)가 없어 더 안전합니다.
