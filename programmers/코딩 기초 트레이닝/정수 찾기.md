# 정수 찾기

## 문제 설명

정수 리스트 `num_list`와 찾으려는 정수 `n`이 주어질 때, `num_list`안에 `n`이 있으면 1을 없으면 0을 return하도록 solution 함수를 완성해주세요.

## 제한사항

- 3 ≤ `num_list`의 길이 ≤ 100
- 1 ≤ `num_list`의 원소 ≤ 100
- 1 ≤ `n` ≤ 100

## 입출력 예

| num_list            | n   | result |
| ------------------- | --- | ------ |
| [1, 2, 3, 4, 5]     | 3   | 1      |
| [15, 98, 23, 2, 15] | 20  | 0      |

## 입출력 예 설명

**입출력 예 #1**

- [1, 2, 3, 4, 5] 안에 3이 있으므로 1을 return합니다.

**입출력 예 #2**

- [15, 98, 23, 2, 15] 안에 20이 없으므로 0을 return합니다.

## 풀이 코드

### 방법 1: includes() 메서드 사용

```javascript
function solution(num_list, n) {
  return num_list.includes(n) ? 1 : 0;
}
```

### 방법 2: find() 메서드 사용 (수정된 버전)

```javascript
function solution(num_list, n) {
  return num_list.find((item) => item === n) !== undefined ? 1 : 0;
}
```

### 방법 3: some() 메서드 사용

```javascript
function solution(num_list, n) {
  return num_list.some((item) => item === n) ? 1 : 0;
}
```

### 방법 4: for 반복문 사용

```javascript
function solution(num_list, n) {
  for (let i = 0; i < num_list.length; i++) {
    if (num_list[i] === n) {
      return 1;
    }
  }
  return 0;
}
```

## 고민한 점

### 원래 코드의 문제점

```javascript
function solution(num_list, n) {
  return num_list.find((item) => item === n) > 0 ? 1 : 0;
}
```

이 코드에는 몇 가지 문제가 있습니다:

1. **`find()` 메서드의 반환값 오해**: `find()`는 조건에 맞는 첫 번째 요소를 반환하거나, 찾지 못하면 `undefined`를 반환합니다. 숫자 0이 배열에 있을 때 `find()`가 0을 반환하면, `0 > 0`은 `false`가 되어 잘못된 결과가 나옵니다.

2. **예시 케이스**: `[1, 2, 3, 4, 5]`에서 3을 찾을 때, `find()`는 3을 반환하고 `3 > 0`은 `true`가 되어 1을 반환합니다. 하지만 `[0, 1, 2]`에서 0을 찾을 때, `find()`는 0을 반환하고 `0 > 0`은 `false`가 되어 0을 반환하게 됩니다.

### 올바른 해결 방법

- `includes()` 메서드: 가장 직관적이고 간단한 방법
- `find()` 메서드: `undefined`와 비교하여 존재 여부 확인
- `some()` 메서드: 조건에 맞는 요소가 하나라도 있는지 확인
- 반복문: 가장 기본적인 방법

## 더 알아본 점

### JavaScript 배열 메서드 비교

1. **`includes()`**: 값이 배열에 포함되어 있는지 확인 (ES2016)
2. **`find()`**: 조건에 맞는 첫 번째 요소 반환 (ES2015)
3. **`some()`**: 조건에 맞는 요소가 하나라도 있는지 확인 (ES2015)
4. **`indexOf()`**: 값의 인덱스 반환, 없으면 -1 반환

### 성능 고려사항

- 작은 배열에서는 모든 방법이 비슷한 성능
- 큰 배열에서는 `includes()`나 `some()`이 더 효율적일 수 있음
- `find()`는 첫 번째 요소를 찾으면 즉시 반환하므로 조건에 따라 효율적

### 타입 안전성

- `includes()`는 엄격한 비교(`===`)를 사용
- `NaN`의 경우 `includes()`는 올바르게 처리하지만 `indexOf()`는 처리하지 못함
