# 홀짝에 따라 다른 값 반환하기

## 문제 설명

양의 정수 n이 매개변수로 주어질 때:

- n이 홀수라면 n 이하의 홀수인 모든 양의 정수의 합을 return
- n이 짝수라면 n 이하의 짝수인 모든 양의 정수의 제곱의 합을 return

**제한사항**

- 1 ≤ n ≤ 100

**입출력 예**

- n = 7: 1 + 3 + 5 + 7 = 16
- n = 10: 2² + 4² + 6² + 8² + 10² = 4 + 16 + 36 + 64 + 100 = 220

## 해결 방법

### 기존 코드

```javascript
function solution(n) {
  let arr = [];
  for (i = 1; i <= n; i++) {
    arr.push(i);
  }
  return n % 2 == 0
    ? arr
        .filter((item) => item % 2 == 0)
        .map((item) => item ** 2)
        .reduce((a, b) => a + b, 0)
    : arr.filter((item) => item % 2 != 0).reduce((a, b) => a + b, 0);
}
```

### 개선된 코드

```javascript
function solution(n) {
  let sum = 0;
  if (n % 2 === 0) {
    for (let i = 2; i <= n; i += 2) {
      sum += i * i;
    }
  } else {
    for (let i = 1; i <= n; i += 2) {
      sum += i;
    }
  }

  return sum;
}
```

## 고민한 점

1. **효율성 개선**: 기존 코드는 1부터 n까지 모든 수를 배열에 담고 필터링하는 방식으로 불필요한 메모리 사용과 연산이 많았습니다. 개선된 코드는 필요한 수만 직접 계산하여 시간복잡도를 O(n)에서 O(n/2)로 줄였습니다.

2. **메모리 최적화**: 배열을 생성하지 않고 변수 하나만 사용하여 메모리 사용량을 크게 줄였습니다.

3. **가독성 향상**: 삼항 연산자로 한 줄에 작성된 복잡한 로직을 if-else 문으로 분리하여 코드의 의도를 명확하게 했습니다.

4. **루프 최적화**: 홀수/짝수 판별에 따라 시작점과 증가폭을 다르게 설정하여 불필요한 조건 검사를 제거했습니다.
